# 의사결정 로그

프로젝트의 주요 기술적 결정과 그 배경을 기록합니다.

---

## 작성 가이드

각 의사결정은 다음 형식으로 기록:

```markdown
## [결정 제목]

**일자**: YYYY-MM-DD
**상태**: 결정됨 / 검토중 / 폐기됨
**관련 커밋**: `해시` 또는 PR 링크

### 컨텍스트
- 어떤 상황에서 이 결정이 필요했는가?

### 선택지
1. **선택지 A** - 장점 / 단점
2. **선택지 B** - 장점 / 단점
3. **선택지 C** - 장점 / 단점

### 결정
- 어떤 선택을 했는가?
- 왜 이 선택을 했는가?

### 결과
- 결정 후 어떤 영향이 있었는가?
- 예상과 다른 점은?

### 회고 (선택)
- 다시 결정한다면?
- 배운 점?
```

---

## UI 아키텍처: MVP → Widget

**일자**: 2024-XX-XX
**상태**: 결정됨
**관련 커밋**: `6792d60`

### 컨텍스트
- 초기 UI 설계에서 MVP(Model-View-Presenter) 패턴 검토
- Unity의 GameObject 기반 UI와 전통적 MVP의 괴리 발견

### 선택지
1. **MVP 패턴 유지**
   - 장점: 테스트 용이, 관심사 분리 명확
   - 단점: Unity UI와 맞지 않는 추상화, 보일러플레이트 증가

2. **Widget 기반 시스템**
   - 장점: Unity 친화적, 계층 구조 자연스러움
   - 단점: 테스트가 MonoBehaviour에 종속

3. **MVVM 패턴**
   - 장점: 데이터 바인딩 강점
   - 단점: Unity에서 구현 복잡, 오버엔지니어링 우려

### 결정
**Widget 기반 시스템** 선택

**이유**:
- Unity의 GameObject 계층 구조와 자연스럽게 매핑
- Prefab 기반 UI 워크플로우와 호환
- 실용적인 수준의 복잡도 유지

### 결과
- Screen/Popup/Navigation 구조가 직관적으로 구현됨
- Prefab 기반 작업 흐름 유지
- 테스트는 PlayMode 테스트로 대응

---

## Assembly Definition 모듈화 전략

**일자**: 2024-XX-XX
**상태**: 결정됨
**관련 커밋**: `968b75d`

### 컨텍스트
- 프로젝트 규모 성장에 따른 컴파일 시간 증가 우려
- 코드 의존성 명시적 관리 필요

### 선택지
1. **Assembly 없이 진행**
   - 장점: 설정 단순
   - 단점: 컴파일 시간 증가, 순환 참조 위험

2. **기능별 Assembly 분리**
   - 장점: 컴파일 최적화, 의존성 명시
   - 단점: 초기 설정 비용

3. **Layer별 Assembly 분리**
   - 장점: 아키텍처 레이어 강제
   - 단점: 기능 추가 시 여러 Assembly 수정 필요

### 결정
**기능별 Assembly 분리** (`Sc.` 접두사)

**이유**:
- 각 기능이 독립적으로 컴파일/테스트 가능
- 의존성 그래프 명시적 관리
- 순환 참조 컴파일 타임 방지

### 결과
- Core, UI, Contents 등 명확한 모듈 경계
- 새 기능 추가 시 의존성 설계 강제
- Editor 전용 코드 완전 분리 가능

---

## 이벤트 기반 컨텐츠 통신

**일자**: 2024-XX-XX
**상태**: 결정됨
**관련 커밋**: `f5a5f11`

### 컨텍스트
- 컨텐츠(캐릭터, 인벤토리, 퀘스트 등) 간 통신 방식 필요
- 직접 참조 시 강한 결합 발생

### 선택지
1. **직접 참조**
   - 장점: 단순, IDE 지원 좋음
   - 단점: 강한 결합, 순환 참조 위험

2. **이벤트 버스**
   - 장점: 느슨한 결합, 확장 용이
   - 단점: 흐름 추적 어려움, 타입 안전성 감소

3. **메시지 브로커 패턴**
   - 장점: 중앙 집중 관리
   - 단점: 복잡도 증가

### 결정
**이벤트 버스** (타입 안전 이벤트)

**이유**:
- 컨텐츠 간 의존성 제거
- 새 컨텐츠 추가 시 기존 코드 수정 최소화
- 제네릭 기반 타입 안전성 확보

### 결과
- Contents 간 Assembly 참조 없음
- 기능 추가/제거 시 영향 범위 최소화
- 이벤트 정의를 통한 계약 명시

---

## 데이터 아키텍처: 로컬 중심 → 서버 중심

**일자**: 2025-01-15
**상태**: 결정됨
**관련 커밋**: `0da3d36`

### 컨텍스트
- 초기 데이터 아키텍처(v1.0)는 로컬 중심 설계
- IDataService로 클라이언트에서 직접 데이터 수정 가능
- 라이브 서비스 기준으로 보면 서버 검증 없는 설계는 치팅에 취약
- 포트폴리오 목적상 실제 서비스와 유사한 아키텍처 필요

### 선택지
1. **로컬 중심 유지 (v1.0)**
   - 장점: 구현 단순, 빠른 개발
   - 단점: 서버 검증 불가, 치팅 취약, 실무와 괴리

2. **서버 중심 + 로컬 시뮬레이션 (v2.0)**
   - 장점: 라이브 서비스 아키텍처, 인터페이스만 교체하면 서버 연동
   - 단점: 초기 구현 복잡도 증가

3. **실제 서버 구현**
   - 장점: 완전한 서버-클라이언트 구조
   - 단점: 범위 초과, 백엔드 인프라 필요

### 결정
**서버 중심 + 로컬 시뮬레이션 (v2.0)** 선택

**이유**:
- 설계는 서버 중심(Server Authority)으로 하되, 구현은 LocalApiClient로 시뮬레이션
- 인터페이스(IApiClient)만 교체하면 실제 서버 연동 가능
- Delta 패턴으로 부분 갱신 효율화
- 포트폴리오에서 "라이브 서비스 고려한 설계" 어필 가능

### 결과
- DataManager: 읽기 전용 뷰만 제공 (직접 수정 메서드 제거)
- SetUserData: 로그인 시 전체 데이터 설정
- ApplyDelta: 이후 액션은 변경분만 적용
- LocalApiClient: 서버 응답 시뮬레이션 (100ms 지연, JSON 저장)

### 회고
- v1.0 구현 후 리셋하는 비용 발생 (git reset 사용)
- 초기 설계 단계에서 라이브 서비스 기준으로 검토했으면 리워크 방지 가능
- **배운 점**: 포트폴리오여도 실제 서비스 기준으로 설계해야 가치 있음

---

## Delta 패턴 도입

**일자**: 2025-01-15
**상태**: 결정됨
**관련 커밋**: `0da3d36`

### 컨텍스트
- 서버 중심 아키텍처에서 유저 데이터 갱신 방식 결정 필요
- 매번 전체 데이터 동기화는 비효율적

### 선택지
1. **전체 동기화**
   - 장점: 구현 단순, 데이터 일관성 보장
   - 단점: 네트워크/메모리 비효율, 대역폭 낭비

2. **Delta 패턴 (변경분만 전달)**
   - 장점: 네트워크 효율, 부분 갱신으로 성능 향상
   - 단점: 적용 로직 복잡, Nullable 처리 필요

3. **이벤트 소싱**
   - 장점: 변경 이력 추적, 롤백 가능
   - 단점: 오버엔지니어링, 구현 복잡도 높음

### 결정
**Delta 패턴** 선택

**이유**:
- 실제 모바일 게임에서 보편적으로 사용하는 패턴
- Nullable 타입으로 변경 여부 명확히 표현
- 로그인: 전체 데이터, 이후 액션: Delta만

### 결과
- UserDataDelta 클래스 설계 (Profile?, Currency?, AddedCharacters, RemovedCharacterIds, ...)
- DataManager.ApplyDelta() 구현
- GachaResponse, ShopPurchaseResponse 등에 Delta 포함

---

## [템플릿] 새 의사결정

**일자**: YYYY-MM-DD
**상태**: 검토중
**관련 커밋**: ``

### 컨텍스트
-

### 선택지
1. **선택지 A**
   - 장점:
   - 단점:

### 결정


### 결과

